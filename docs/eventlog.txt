Title:  The event/data logging system for swarm
Author: mjuric

=========================

Despite the horrendously complicated implementation in swarmlog.h, the ideas
behind it are quite simple:

* There are two "event log buffer" objects to which the user can log events,
  or the current states of systems being integrated: clog and glog. clog is
  must be used by the CPU code, glog is to be used by the GPU code, but
  otherwise their interfaces are completely identical. Currently, these
  are global objects, both on CPU and GPU (somewhat like cout in C++)

* There are two types of messages you can send to these log buffers, that
  get stored to their individual sub-buffers:

  1) Bodies - using log_body(ens, sys, bod, T) you can store the current
              (m,x,v,T) coordinates of a body bod in system sys, plus an
              integer worth of arbitrary user data. Look at 
              eventlog_base::body structure to see what is stored.
  2) Events - these are general purpose records, not longer than ~200 bytes,
              that begin with an integer eventId and then store whatever data
              you choose. Use log_event() set of templated functions to log
              events. Their effective interface look like:

		void log_event(int evtId, ...)

              where ... stands for up to 9 variables of arbitrary types
              (think printf and co.). The machinery beneath these functions
              will byte-copy all variables into the buffer. Example usage:

                #define EVT_COLLISION 1
                   ....
                glog.log_event(EVT_COLLISION, bod1, bod2);

  2a) Printf- an implementation of C printf() function, callable from a GPU.
              Internally, these are just events with event ID EVT_PRINTF, 
              but they also have a set of convenience template functions
              that makes the interface look exactly like that of printf().
              On the CPU side, there's some code to recognize EVT_PRINTF
              events for what they are and call C's printf() on their data.
              GPU interface:

                glog.printf("Debug: body %d just hit body %d", bod1, bod2);

  From the integrator-developer's point of view, these functions allow an
  easy way to record that something has happened in the simulation, and to
  store a (sub)set of bodies related to that event of interest.  These
  events and accompanying data will be marshalled to output files for
  subsequent data analysis. For example, let's say you want to record a
  collision event between bodies bod1 and bod2:

    int evtref = glog.log_event(EVT_COLLISION, sys, bod1, bod2, T)l
    glog.log_body(ens, sys, bod1, T, evtref);
    glog.log_body(ens, sys, bod2, T, evtref);

  The above stored a user-defined event (EVT_COLLISION) to the event log,
  recording the system, the bodies involved, and the time of the collision.
  Subsequent two lines stored all the information about the bodies (masses,
  position, velocities..), together with the event reference (evtref) which
  can be used in the subsequent analysis to match these two entries in the
  outputs with the reason why they're there.

* For now, the event buffers cannot be read directly but are "piped" to a
  "writer" object. A writer is an object that inherits from abstract class
  writer, and is attached to clog using the clog's attach_sink() function.
  The writer implements 'void process(ieventstream &)' method that when
  called should drain the buffers of all events (usually storing them to a
  file, or outputting some to the screen (e.g., the printfs)). The
  process(ieventstream &) method will be called whenever the event buffer 
  is flushed (more below).

  The argument, an ieventstream object, provides istream-like interface to
  the eventlog.  Example: if you stored the following event (eg., either in
  GPU code, or CPU code):

    #define EVT_MYEVENT 1
    int i = 2; double x = 3.; float2 xy = {2., 4.}
    glog.log_event(EVT_MYEVENT, i, x, xy);

  when passed an ieventstream object es, you'd read it as follows:

    switch(es.next())// advances to next event, returning its event ID
    {
    case EVT_MYEVENT:
       int i; double x; float2 xy;
       es >> i >> x >> xy;
       ... do something useful ...
       break;
    ...
    }

  This is only for reading events. For accessing the sub-buffer holding the
  bodies, an array-like interface is provided instead.

  Example implementation of a writer is class binary_writer, in
  swarmlog.cpp.  binary_writer just binary-dumps the bodies and events
  sub-buffer into two files, while printf-ing any EVT_PRINTF events to the
  screen.

* Both the CPU and GPU buffers have limited reserved space (which is why I
  refer to them here as buffers). Periodically, they have to be flushed;
  otherwise they'll start drooping events/bodies.

  Flushing is accomplished by calling clog.flush() (immediate), or via
  clog.flush_if_needed() (that will flush only if buffers are near
  capacity).  There's no explicit call to flush the GPU buffer --
  clog.flush* family will take care of that.

  Best practice: call flush_if_needed() after every kernel call (for GPU
  kernels), or after every step (CPU kernels).

* Finally, before they can be used the eventlog buffers must be initialized
  by calling clog.initialize(), and a sink must be attached via
  clog.attach_sink().  See swarm.cpp for an example.

* Post-final notes: The implementation is rather dirty at this point, as I
  didn't have the time to make it prettier.  The design has passed through a
  few redesigns, and there may be vestiges of the old code here and there
  (so if something seems wrong or illogical, that may be the reason).  For
  the same reason, a number of variable names are misnomers.  There are also
  likely to be many, many, many bugs.

