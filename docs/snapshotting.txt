Title:  Storing the current state of the system (snapshotting) in swarm
Author: mjuric

=========================

* For now the only built-in snapshotting we have is to store the state of
  the system every user-specified time dT.  And that is only for the kernels
  that support it (gpu_euler as of Jan/28/10).

* ensemble structure has been extended with one 2D double precision array,
  Toutput, accessable using time_output(sys, k) method.  For each system,
  k=0 values in this array give the desired time of next snapshot.
  Initially, these are all initialized to Tstart (the initial conditions).
  A snapshot will be made on the first integration step when
  T>=Toutput(sys,0). k=1 values are the output intervals; that is, after a
  snapshot is made, the next snapshot time is calculated as Toutput(sys,0)
  = T + Toutput(sys, 1).

  While in principle the output intervals could be different for each system
  in the ensemble, for now we only allow a single output interval for all
  systems, specified through the configuration key 'output interval'. See
  swarm.cpp (around line 45) for what is done.

* To snapshot-enable your kernel, simply call output_if_needed(glog, ens, T,
  sys) from your kernel, just before you will advance the system by a
  timestep.  Also call it just before exiting the kernel (to allow a final
  snapshot to be made, if needed).  output_if_needed() is defined in
  swarmlib.cu -- take a look what it does.

* Snapshotting relies on the eventlog system to receive the snapshots (so go
  read docs/eventlog.txt if you already haven't). It does the following:

	int evtref = glog.log_event(EVT_SNAPSHOT, sys, T);
	glog.log_system(ens, sys, T, evtref);

  where log_system() simply calls log_body for each body. To locate a
  particular snapshot in the output files, first locate the EVT_SNAPSHOT
  event closest to the desired time, find its evtref and look up the
  corresponding bodies in the bodies.bin output file.

* Note that the snapshotting subsystem is orthogonal to other changes (e.g.,
  refactoring of kernels to use propagator/stopper interfaces).  It can be
  called from custom/optimized GPU kernels, as well as CPU code.
