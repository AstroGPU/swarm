Makefile-based swarm build system
=================================
Mario Juric


Overview
--------
* Usage:

       make all

  The outputs (applications, shared libraries) will be stored to bin/
  subdirectory.  To clean up:

       make clean

  or if you want to clean up even more:

       make tidy

* Requirements:
	- GNU make
	- GNU ld
	- GNU GCC g++
	- nvcc (ver. 2.0 or later)

* Overriding default compiler/tools locations

  To tell the build system where to find various tools and libraries it may
  need, override the built-in values by creating Makefile.user in the top
  directory.  Take a look at the Makefile (where it says 'Defaults') to see
  which variables you can override.  Typically, you'd override CCUDA
  (location of nvcc) or DEVEMU (that you'd set to --device-emulation to
  compile in device emulation mode).

<<<<<<< HEAD:docs/build_system.txt
* To disable the 'pretty printing' during the build process, define
  VERBOSE=1 in your Makefile.user (or the environment).

=======
>>>>>>> eford:docs/build_system.txt

Advanced Features
-----------------

* To disable the 'pretty printing' during the build process, define
  VERBOSE=1 in your Makefile.user (or the environment)

* Unless something is wrong, or you want to tinker with the Makefiles, or
  you're trying to diagnose a bug you suspect is caused by the build system,
  the rest of this document shouldn't be of interest to you.

* The main Makefile is in the top source directory. Its purposes are:

    * To build the core swarm code into a shared library (bin/libswarm.so)

    * To build various applications using the swarm code (e.g., swarm -- the
      integrator, swarmdump -- output file inspector, etc.)

    * To help the developer by tracking dependencies and rebuilding the code
      as needed.

* To build libswarm.so, the Makefile:
 
    * Includes Makefiles matching integrators/*/Makefile.mk pattern.
      These files should add any integrator-specific sources to
      LIBSWARM_CUDA (.cu files) or LIBSWARM_SOURCES (.cpp files).  See the
      text on top of, e.g., integrators/euler/Makefile.mk for more
      instructions

    * Concatenates all .cu files (the ones from LIBSWARM_CUDA) into a single
      temporary .cu file to ensure there's only one copy of CUDA static
      variable in the program (trust me, less headaches later.)

    * Compiles the autogenerated .cu, and any .cpp files from LIBSWARM_CUDA,
      and archives them to a shared library.

* To build the applications

    * Applications are excutables that link against libswarm.so, and add
      their own main() routine. The makefile ensures libswarm is built (and
      up to date) before it tries to build the applications.

    * To add an application, add its name to the APPS makefile variable, and
      specify a list of its sources in <appname>_SOURCES variable (where
      <appname> is the name of the application).  The build system will take
      care of the rest (dependency tracking, linking, etc.).  See the top of
      Makefile for examples (swarm and swarmdump).

    * All apps are linked agains libswarm.so. This is a shared library, and
      the system needs to know where to find it. The build system takes care
      of this for you by hardcoding the path to ...../bin/libswarm.so into
      your application (so-called 'rpath' option).  Otherwise you'd have
      specify LD_LIBRARY_PATH to the library (which is a pain).

      WARNING: In the future, we'll have to provide a 'make install' target,
      that will relink the binary without the rpath option.  While the file
      with hardcoded rpath will work if it's copied elsewhere and
      LD_LIBRARY_PATH is set, it may present a security issue (as it's my
      understanting that rpath is searched _before_ LD_LIBRARY_PATH).

* Dependency tracking

    * Dependency generation/tracking is automatic. The implementation is
      based on the advice from the GNU make manual (google 'Generating
      Dependencies Automatically').
